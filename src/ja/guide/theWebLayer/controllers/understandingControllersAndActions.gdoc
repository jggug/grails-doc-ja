h4. コントローラを作成する

{hidden}Controllers can be created with the [create-controller|commandLine] or [generate-controller|commandLine] command. For example try running the following command from the root of a Grails project:{hidden}
[create-controller|commandLine]または[generate-controller|commandLine]コマンドでコントローラが作成できます。Grailsプロジェクトのルートで以下のようにコマンドを実行します。

{code:java}
grails create-controller book
{code}

{hidden}The command will create a controller at the location @grails-app/controllers/myapp/BookController.groovy@:{hidden}
コマンドを実行すると@grails-app/controllers/myapp/BookController.groovy@にコントローラを生成します。

{code:java}
package myapp

class BookController {

    def index() { }
}
{code}

{hidden}where "myapp" will be the name of your application, the default package name if one isn't specified.{hidden}
パッケージ名を指定しない場合は、"myapp"というアプリケーション名であれば、自動的にデフォルトパッケージとして生成されます。

{hidden}@BookController@ by default maps to the /book URI (relative to your application root).{hidden}
デフォルトでは、@BookController@は、URIが /bookとなります。(アプリケーションのコンテキストルートからの相対パス)

{hidden}{note}
The @create-controller@ and @generate-controller@ commands are just for convenience and you can just as easily create controllers using your favorite text editor or IDE
@create-controller@と@generate-controller@コマンドは、簡単にコントローラを生成する便利なコマンドですが、IDEやテキストエディタの機能でクラスを作成してもかまいません。
{note}{hidden}
{note}
@create-controller@と@generate-controller@コマンドは、簡単にコントローラを生成する便利なコマンドですが、IDEやテキストエディタの機能でクラスを作成してもかまいません。
{note}

h4. アクションの作成

{hidden}A controller can have multiple public action methods; each one maps to a URI:{hidden}
コントローラは複数のアクションメソッドを持つことができます。それぞれURIにマップされます:

{code:java}
class BookController {

    def list() {

        // do controller logic
        // create model

        return model
    }
}
{code}

{hidden}This example maps to the @/book/list@ URI by default thanks to the property being named @list@.{hidden}
この例では、アクションメソッド名が@list@なので、URIは@/book/list@にマップされます。

h4. パブリックメソッドをアクションとする

{hidden}In earlier versions of Grails actions were implemented with Closures. This is still supported, but the preferred approach is to use methods.{hidden}
以前のバージョンまでは、アクションがクロージャで実装されてました。この方式はまだサポートされています。ただし今後のアクションの実装はメソッドを使用することを推奨します。

{hidden}Leveraging methods instead of Closure properties has some advantages:{hidden}
クロージャではなく、メソッドにすることによって以下の利点があります:
{hidden}
* Memory efficient
* Allow use of stateless controllers (@singleton@ scope)
* You can override actions from subclasses and call the overridden superclass method with @super.actionName()@
* Methods can be intercepted with standard proxying mechanisms, something that is complicated to do with Closures since they're fields.
{hidden}
* メモリ効率
* ステートレスコントローラの使用 (@シングルトンスコープ@指定)
* サブクラスでのアクションのオーバーライドが可能。スーパークラスのアクションメソッド呼び出しが可能。@super.actionName()@
* クロージャはフィールドのため複雑だった、スタンダードなプロキシを使用したメソッドのインターセプトが可能。

{hidden}If you prefer the Closure syntax or have older controller classes created in earlier versions of Grails and still want the advantages of using methods, you can set the @grails.compile.artefacts.closures.convert@ property to true in @BuildConfig.groovy@:{hidden}
クロージャを使用したい場合や、旧バージョンで作られたコントローラを使用しながら、メソッドの利点も欲しい場合は、@BuildConfig.groovy@に、 @grails.compile.artefacts.closures.convert@を定義します:
{code}
grails.compile.artefacts.closures.convert = true
{code}

{hidden}and a compile-time AST transformation will convert your Closures to methods in the generated bytecode.{hidden}
この定義をすることで、AST変換を使用してクロージャをメソッドに変換したバイトコードを生成します。

{note}
If a controller class extends some other class which is not defined under the @grails-app/controllers/@ directory, methods inherited from that class are not converted to controller actions.  If the intent is to expose those inherited methods as controller actions the methods may be overridden in the subclass and the subclass method may invoke the method in the super class.
{note}

h4. デフォルトアクション

{hidden}A controller has the concept of a default URI that maps to the root URI of the controller, for example @/book@ for @BookController@. The action that is called when the default URI is requested is dictated by the following rules:{hidden}
コントローラのルートURIににデフォルトURIをマップする概念をもっています。例として@BookController@の場合は @/book@になります。デフォルトURIが呼ばれたときに呼ばれるアクションは以下のルールになっています:
{hidden}
* If there is only one action, it's the default
* If you have an action named @index@, it's the default
* Alternatively you can set it explicitly with the @defaultAction@ property:
{hidden}
* アクションが１つの場合は、それがデフォルトになります。
* @index@という名称のアクションがある場合は、それがデフォルトになります。
* @defaultAction@を定義して指定できます。

{code:java}
static defaultAction = "list"
{code}
