{hidden}Within the body of the filter you can then define one or several of the following interceptor types for the filter:{hidden}
フィルタの中に、幾つかのインターセプタを定義することができます。

{hidden}
* @before@ - Executed before the action. Return @false@ to indicate that the response has been handled that that all future filters and the action should not execute
* @after@ - Executed after an action. Takes a first argument as the view model to allow modification of the model before rendering the view
* @afterView@ - Executed after view rendering.  Takes an Exception as an argument which will be non-@null@ if an exception occurs during processing. Note: this Closure is called before the layout is applied.
{hidden}
* @before@ - アクションの前に実行されます。@false@を返す事で、その後に実行されるフィルタとアクションは実行されません。
* @after@ - アクションの後に実行されます。最初の引数に、ビューレンダリング前に変更可能なビューモデルが渡されます。
* @afterView@ - ビューレンダリング後に実行されます。実行時に例外が発生した場合は@non-null@なExceptionが引数として渡されます。このクロージャはレイアウトが適用される前に実行されます。


{hidden}For example to fulfill the common simplistic authentication use case you could define a filter as follows:{hidden}
シンプルな認証の仕組みとしてフィルタを定義する例です:
{code:java}
class SecurityFilters {
   def filters = {
       loginCheck(controller: '*', action: '*') {
           before = {
              if (!session.user && !actionName.equals('login')) {
                  redirect(action: 'login')
                  return false
               }
           }
       }
   }
}
{code}

{hidden}Here the @loginCheck@ filter uses a @before@ interceptor to execute a block of code that checks if a user is in the session and if not redirects to the login action. Note how returning false ensure that the action itself is not executed.{hidden}
この@loginCheck@フィルタは、@before@インターセプタのコードブロックを実行することで、ユーザがセッションに無い場合はloginアクションへリダイレクトしています。falseを返す事で対象のアクション自身が実行されないようにします。
